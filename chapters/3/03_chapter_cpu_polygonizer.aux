\relax 
\citation{Shirazian2012}
\citation{Shirazian2012}
\citation{Bloomenthal1997}
\citation{Wyvill1999}
\citation{Bloomenthal1997}
\citation{gomes2009implicit}
\citation{Grascuel1997}
\@writefile{toc}{\contentsline {chapter}{\numberline {3}High Performance Rendering on Multi-Core Architectures}{25}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapter:cpuPoly}{{3}{25}}
\citation{Schmidt2006}
\citation{Bernhardt2010a}
\citation{Schmidt2006}
\citation{Laycock2007}
\citation{Wyvill1986}
\citation{Lorensen1987}
\@writefile{toc}{\contentsline {section}{\numberline {3.1}Related Work}{26}}
\newlabel{sec:relatedwork}{{3.1}{26}}
\citation{Bloomenthal1994a}
\citation{guziec1995exploiting}
\citation{Dietrich2009}
\citation{Wyvill1986}
\citation{Triquet2003}
\citation{Bloomenthal1994a}
\citation{mackerras1992fast}
\citation{hansen1992massively}
\citation{Kipfer2005}
\citation{Johansson2006}
\citation{Cignoni1997}
\citation{tatarchuk2008advanced}
\citation{Yang2010}
\citation{Rodriguesdearaujo2005}
\citation{Knoll2007}
\citation{SWG2005}
\@writefile{toc}{\contentsline {section}{\numberline {3.2}Architecture Constraints}{29}}
\newlabel{sec:architecture}{{3.2}{29}}
\citation{Wyvill1986}
\@writefile{toc}{\contentsline {section}{\numberline {3.3}Naming Conventions}{30}}
\newlabel{sec:naming}{{3.3}{30}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.1}{\ignorespaces  {The \textit  {MPU} is our unit of computation per each core illustrated as a 2D cross section here. Field-values due to every 4 or 8 points are computed in parallel with SSE or AVX instructions, respectively. When the field at a vertex is zero no iso-surface will pass in the neighbourhood of a unit circle (sphere in 3D) centred at that vertex.} }}{31}}
\newlabel{fig:MPU}{{3.1}{31}}
\@writefile{toc}{\contentsline {section}{\numberline {3.4}Algorithm}{31}}
\newlabel{sec:algorithm}{{3.4}{31}}
\citation{Reinders2007}
\citation{Reinders2007}
\citation{Fox2001}
\citation{Lee2000}
\citation{Wyvill1986}
\citation{Lorensen1987}
\citation{Bloomenthal1994a}
\@writefile{lof}{\contentsline {figure}{\numberline {3.2}{\ignorespaces  {Left Column: The one-time preparation steps before scheduling kernel functions for computation. Middle Column: The early discard kernel function. Right Column: The $MPU$ processing kernel function.} }}{33}}
\newlabel{fig:AlgorithmHighLevelView}{{3.2}{33}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.4.1}BlobTree Linearization}{33}}
\newlabel{sec:linearization}{{3.4.1}{33}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.4.2}Surface Extraction}{33}}
\newlabel{sec:surfaceextraction}{{3.4.2}{33}}
\citation{Zhang2006}
\citation{Bolosky1993}
\citation{Lorensen1987}
\citation{Dietrich2009}
\citation{Wyvill1986}
\citation{Dietrich2009}
\citation{Matthews1987}
\@writefile{loa}{\contentsline {algorithm}{\numberline {1}{\ignorespaces SIMD computation of cell configuration. Pseudo code provided for AVX SIMD computation. Similar code can be written in SSE.}}{35}}
\newlabel{alg:cellconfig}{{1}{35}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.3}{\ignorespaces  {Top: A cell edge is intersected with part of the surface shown in blue. By performing one field evaluation using AVX or two with SSE instructions the interval containing the intersection point can be identified. The final root is computed using linear interpolation within the interval marked with bold line segment.} }}{36}}
\newlabel{fig:root}{{3.3}{36}}
\@writefile{toc}{\contentsline {section}{\numberline {3.5}Results}{36}}
\newlabel{sec:results}{{3.5}{36}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {2}{\ignorespaces Algorithm for surface extraction of an \textit  {MPU} using AVX SIMD instructions, Similar code can be written for SSE instruction set. Input is linearized BlobTree $T$, lower vertex of \textit  {MPU} and the \textit  {cellsize} parameter. Output is the local mesh contained in the \textit  {MPU}}}{37}}
\newlabel{alg:surfaceextraction}{{2}{37}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.4}{\ignorespaces  {Average polygonization time of the towers model when running on SNB processor. Horizontal axis is the number of threads. Vertical axis is time measured in milliseconds.} }}{39}}
\newlabel{fig:PerfSNBTower}{{3.4}{39}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.5}{\ignorespaces  {Average polygonization time of the towers model when running on NHM processor. Horizontal axis is the number of threads. Vertical axis is time measured in milliseconds.} }}{39}}
\newlabel{fig:PerfXeonTower}{{3.5}{39}}
\citation{SWG2005}
\citation{SWG2005}
\citation{SWG2005}
\@writefile{lot}{\contentsline {table}{\numberline {3.1}{\ignorespaces {Comparison of speedups and field value evaluations per triangle (\textit  {FVEPT}) for polygonization of Tower model with different SIMD instruction sets. Note that FVEPT was 17 before adding SIMD optimizations.}}}{40}}
\newlabel{table:speedup}{{3.1}{40}}
\citation{SWG2005}
\citation{SWG2005}
\@writefile{lof}{\contentsline {figure}{\numberline {3.6}{\ignorespaces  {Reducing cellsize parameter results in more \textit  {MPU} generation and increase in polygonization time. However, at a certain cellsize our early discard method stops polygonization time increase by rejecting all empty \textit  {MPU}s more efficiently.} }}{41}}
\newlabel{fig:DiscardEffect}{{3.6}{41}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.7}{\ignorespaces  {Towers model per-core time breakdowns. Each bar represents a logical core on the processor for a total of 12 cores. Vertical axis is the total polygonization time. 190463 \textit  {MPU}s processed with 12 cores in 9283 milliseconds. This chart shows the portion of time spent in each step of the algorithm when rendering the towers model on the SNB processor with 8-wide AVX instructions.} }}{42}}
\newlabel{fig:TowerSNBTimeBreakDown}{{3.7}{42}}
\@writefile{lot}{\contentsline {table}{\numberline {3.2}{\ignorespaces  {Comparison of our polygonization method against Schmidt et al. 's \cite  {SWG2005} when rendering Medusa model at 5 different resolutions on one single core with AVX instructions. All timings are in milliseconds.} }}{42}}
\newlabel{table:stats}{{3.2}{42}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.8}{\ignorespaces  {Towers model created with skeletal primitives and binary operators in our incremental designing system. The model is a grid of 8 by 8 towers for a total of 7360 operators and 7296 primitives.} }}{43}}
\newlabel{fig:ModelTower}{{3.8}{43}}
\@writefile{toc}{\contentsline {section}{\numberline {3.6}Chapter Conclusions}{43}}
\newlabel{sec:futurework}{{3.6}{43}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.9}{\ignorespaces  {Medusa model courtesy of Schmidt et al. \cite  {SWG2005}.} }}{44}}
\newlabel{fig:ModelMedusa}{{3.9}{44}}
\@setckpt{chapters/3/03_chapter_cpu_polygonizer}{
\setcounter{page}{45}
\setcounter{equation}{0}
\setcounter{enumi}{3}
\setcounter{enumii}{0}
\setcounter{enumiii}{0}
\setcounter{enumiv}{0}
\setcounter{footnote}{0}
\setcounter{mpfootnote}{0}
\setcounter{part}{0}
\setcounter{chapter}{3}
\setcounter{section}{6}
\setcounter{subsection}{0}
\setcounter{subsubsection}{0}
\setcounter{paragraph}{0}
\setcounter{subparagraph}{0}
\setcounter{figure}{9}
\setcounter{table}{2}
\setcounter{lofdepth}{2}
\setcounter{lotdepth}{1}
\setcounter{LT@tables}{0}
\setcounter{LT@chunks}{0}
\setcounter{parentequation}{0}
\setcounter{float@type}{16}
\setcounter{algorithm}{2}
\setcounter{ALC@unique}{47}
\setcounter{ALC@line}{42}
\setcounter{ALC@rem}{0}
\setcounter{ALC@depth}{0}
\setcounter{lstnumber}{1}
\setcounter{lstlisting}{0}
}

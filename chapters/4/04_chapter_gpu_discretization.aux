\relax 
\citation{Labelle2007}
\citation{Shewchuk}
\citation{Labelle2007}
\@writefile{toc}{\contentsline {chapter}{\numberline {4}GPU discretization}{45}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapter:GPUDiscretization}{{4}{45}}
\citation{chochlik2012gpu}
\citation{Buatois2006}
\citation{Tatarchuk2007}
\@writefile{toc}{\contentsline {section}{\numberline {4.1}Related Work}{46}}
\citation{Knoll2009}
\citation{singh2010real}
\citation{Kipfer2005}
\citation{Kanai2006a}
\citation{gaster2012heterogeneous}
\citation{Fatahalian2008}
\citation{Nickolls2008}
\citation{peercy2006performance}
\citation{gaster2012heterogeneous}
\@writefile{toc}{\contentsline {section}{\numberline {4.2}Many-cores architectures}{48}}
\@writefile{toc}{\contentsline {section}{\numberline {4.3}Data Structures}{49}}
\newlabel{sec:datastructure}{{4.3}{49}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.1}{\ignorespaces  {The compact \textit  {BlobTree }scenegraph representation for GPU polygonization and tetrahedralization algorithms. The structure is aligned at 16 bytes (4 floats). 1- The header. 2- Skeletal implicit primitives. 3- Operators. 4- Affine transformation nodes. 5- Control points for sketched objects. Refer to section 4.3\hbox {} for details.} }}{50}}
\newlabel{fig:datastructure}{{4.1}{50}}
\citation{Turk1999}
\citation{Grasberger}
\citation{Nickolls2008}
\@writefile{toc}{\contentsline {section}{\numberline {4.4}Memory foot prints}{52}}
\newlabel{sec:memory}{{4.4}{52}}
\@writefile{lot}{\contentsline {table}{\numberline {4.1}{\ignorespaces  {Memory footprint of the input \textit  {BlobTree }in our GPU polygonization algorithm in bytes. The entire \textit  {BlobTree }for a model with 64K nodes (primitives and operators) takes about 20MB in our current system.} }}{54}}
\newlabel{table:memfootprint}{{4.1}{54}}
\@writefile{toc}{\contentsline {section}{\numberline {4.5}Stackless \textit  {BlobTree }traversal}{54}}
\newlabel{sec:stackless}{{4.5}{54}}
\citation{Samet1984}
\citation{Samet1990}
\citation{Popov2007}
\@writefile{lof}{\contentsline {figure}{\numberline {4.2}{\ignorespaces  {Stackless \textit  {BlobTree }traversal algorithm performs faster on deep tree traversals. The route is computed once and encoded into the tree upon transferring the input data structures to the GPU.} }}{56}}
\newlabel{fig:stackless}{{4.2}{56}}
\@writefile{toc}{\contentsline {section}{\numberline {4.6}GPU Surface Extraction Algorithm}{58}}
\citation{Sengupta2007}
\@writefile{loa}{\contentsline {algorithm}{\numberline {3}{\ignorespaces \textit  {ProcessEdges} kernel function counts the number of intersected edges and their corresponding axes. This kernel runs per each vertex of the voxel grid.}}{59}}
\newlabel{alg:processedgeskernel}{{3}{59}}
\citation{Matthews1987}
\citation{VanOverveld2004}
\citation{Dietrich2009}
\@writefile{loa}{\contentsline {algorithm}{\numberline {4}{\ignorespaces \textit  {GenerateFaces} kernel function computes the triangle indices per each cell and outputs them directly into an OpenGL index buffer for rasterization. All the buffers can be read back later from the GPU and stored.}}{61}}
\newlabel{alg:generatefaceskernel}{{4}{61}}
\@writefile{toc}{\contentsline {section}{\numberline {4.7}Analysis and Results}{61}}
\@writefile{lot}{\contentsline {table}{\numberline {4.2}{\ignorespaces  {Stackless \textit  {BlobTree }traversal improved the performance of our \textit  {BlobTree }traversal significantly. Here is the comparison of fieldvalue evaluation on the GPU comparing stackless approach to a stack-based implementation for some models. Timings are average of 100 runs.} }}{62}}
\newlabel{table:stackless}{{4.2}{62}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.3}{\ignorespaces  {Sample models for testing our GPU polygonization method. From left to right: Cake, tumor and 3slabs.} }}{62}}
\newlabel{fig:combinedmodels}{{4.3}{62}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.4}{\ignorespaces  {Polygonization time breakdown in milliseconds for the three models shown in the previous section. Vertex processing is the most compute-intensive stage due to the Newthon-Raphson root finding method employed and the evaluation of colors and normals which require additional traversals. } }}{63}}
\newlabel{fig:breakdownpoly}{{4.4}{63}}
\@setckpt{chapters/4/04_chapter_gpu_discretization}{
\setcounter{page}{65}
\setcounter{equation}{1}
\setcounter{enumi}{4}
\setcounter{enumii}{0}
\setcounter{enumiii}{0}
\setcounter{enumiv}{0}
\setcounter{footnote}{0}
\setcounter{mpfootnote}{0}
\setcounter{part}{0}
\setcounter{chapter}{4}
\setcounter{section}{7}
\setcounter{subsection}{0}
\setcounter{subsubsection}{0}
\setcounter{paragraph}{0}
\setcounter{subparagraph}{0}
\setcounter{figure}{4}
\setcounter{table}{2}
\setcounter{lofdepth}{2}
\setcounter{lotdepth}{1}
\setcounter{LT@tables}{0}
\setcounter{LT@chunks}{0}
\setcounter{parentequation}{0}
\setcounter{float@type}{16}
\setcounter{algorithm}{4}
\setcounter{ALC@unique}{67}
\setcounter{ALC@line}{14}
\setcounter{ALC@rem}{0}
\setcounter{ALC@depth}{0}
\setcounter{lstnumber}{38}
\setcounter{lstlisting}{0}
}
